//Поясніть своїми словами, як ви розумієте, як працює прототипне наслідування в Javascript

// Прототипне наслідування в JavaScript - це механізм, що дозволяє об'єктам наслідувати властивості та методи інших об'єктів-прототипів.
// Кожен об'єкт має посилання на свій прототип, який можна використовувати для доступу до властивостей та методів, що визначені в прототипі. При створенні нового об'єкта можна вказати його прототип за допомогою методу Object.create().
// Прототипне наслідування дозволяє створювати багато об'єктів зі спільними властивостями та методами та полегшує обслуговування коду.
// Щодо пам'яті, прототипи дозволяють економно використовувати пам'ять, оскільки вони дозволяють ділитись властивостями та методами між об'єктами,
// замість копіювання їх для кожного об'єкта окремо. Крім того, використання прототипів дозволяє зменшити кількість коду, необхідного для створення ієрархії класів,
// оскільки наслідування можна виконувати за допомогою простого встановлення прототипу.

// Для чого потрібно викликати super() у конструкторі класу-нащадка?

// Коли ми створюємо клас-нащадок в JavaScript, він може наслідувати властивості та методи свого батьківського класу за допомогою ключового слова extends.
// При цьому, конструктор класу-нащадка може бути визначений, але він не замінює конструктор батьківського класу.
// Конструктор батьківського класу може мати певний код для ініціалізації властивостей, що є необхідними для коректної роботи об'єкта.
// Коли ми визначаємо конструктор у класі-нащадку, ми повинні спочатку викликати конструктор батьківського класу за допомогою ключового слова super().
// Виклик super() в конструкторі класу-нащадка дозволяє виконати конструктор батьківського класу, щоб ініціалізувати властивості, які він визначив.
// Таким чином, ми можемо додатково встановити властивості для класу-нащадка, використовуючи доступ до this.

class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }

  speak() {
    super.speak();
    console.log(`${this.name} barks.`);
  }
}

let dog = new Dog("Max", "Labrador");
dog.speak();

//Завдання
//     Створити клас Employee, у якому будуть такі характеристики - name (ім'я), age (вік), salary (зарплата).
//     Зробіть так, щоб ці характеристики заповнювалися під час створення об'єкта.
//     Створіть гетери та сеттери для цих властивостей.
//     Створіть клас Programmer, який успадковуватиметься від класу Employee, і який матиме властивість lang (список мов).
// Для класу Programmer перезапишіть гетер для властивості salary. Нехай він повертає властивість salary, помножену на 3.
// Створіть кілька екземплярів об'єкта Programmer, виведіть їх у консоль.

class Employee {
  constructor(name, age, salary) {
    this._name = name;
    this._age = age;
    this._salary = salary;
  }

  get name() {
    return this._name;
  }

  set name(name) {
    this._name = name;
  }

  get age() {
    return this._age;
  }

  set age(age) {
    this._age = age;
  }

  get salary() {
    return this._salary;
  }

  set salary(salary) {
    this._salary = salary;
  }
}

class Programmer extends Employee {
  constructor(name, age, salary, lang) {
    super(name, age, salary);
    this._lang = lang;
  }

  get lang() {
    return this._lang;
  }

  set lang(lang) {
    this._lang = lang;
  }

  get salary() {
    return this._salary * 3;
  }
}

const programmer1 = new Programmer("John", 30, 5000, ["JavaScript", "Python"]);
const programmer2 = new Programmer("Jane", 25, 6000, ["Java", "C++"]);

console.log(programmer1);
console.log(programmer2);
